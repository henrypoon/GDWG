template <typename N, typename E> bool Graph<N,E>::addNode(const N& node) {
	if (isNode(node)) return false;
	nodes.push_back(std::make_shared<Node>(Node{node}));
	// std::cout << node << std::endl;
	return true;
}

template <typename N, typename E> auto Graph<N,E>::findNode(const N& node) const {
	auto result = std::find_if(nodes.begin(), nodes.end(), [&node] (const std::shared_ptr<Node>& n) {
		return node == n->getNode();
	});
	return result;
}

template <typename N, typename E> auto Graph<N,E>::findNode(const N& node)  {
	auto result = std::find_if(nodes.begin(), nodes.end(), [&node] (const std::shared_ptr<Node>& n) {
		return node == n->getNode();
	});
	return result;
}


// add edge between two nodes
template <typename N, typename E> bool Graph<N,E>::addEdge(const N& src, const N& dst, const E& w) {
	if (!isNode(src)) {
		throw std::runtime_error("Can't find source node");
	}
	if (!isNode(dst)) {
		throw std::runtime_error("Can't find destination node");
	}
	auto from = findNode(src);
	auto to = findNode(dst);

	if ((*from)->isExisted(dst, w)) {
		return false;
	}
	(*from)->addEdge(**to, w);
	return true;
}

// add edge to a node
template <typename N, typename E> bool Graph<N,E>::Node::addEdge(const Node& dst, const E& w) {
	edges.push_back(std::make_shared<Edge>(Edge{dst, w}));
	return true;
}

// replace
template <typename N, typename E> bool Graph<N,E>::replace(const N& oldData, const N& newData) {
	if (!isNode(oldData)) {
		throw std::runtime_error("Can't find oldData");
	}
	if (isNode(newData)) {
		return false;
	}
	auto old = findNode(oldData);
	(*old)->replace(newData);
	return true;
}

template <typename N, typename E> void Graph<N,E>::Node::replace(const N& newData) {
	*nodePtr = newData;
}

template <typename N, typename E> void Graph<N,E>::mergeReplace(const N& oldData, const N& newData) {
	if (!isNode(oldData)) {
		throw std::runtime_error("Can't find oldData");
	}
	// std::cout << newData <<std::endl;
	if (!isNode(newData)) {
		throw std::runtime_error("Can't find newData");
	}
	// printEdges(1);
	auto newD = findNode(newData);
	// auto old = findNode(oldData);

	// old->replace(newData);
	for (auto n: nodes) {
		// n.printNode();
		if (n.getNode() != oldData) {
			// n.replace(newData);
			// std::cout << "temo" << std::endl;
		// } else {
			// n.printEdges();
			n.mergeIn(oldData, *newD, newD->getNodePtr());
			// n.printEdges();
			break;
		}
	}
	// printEdges(1);
}

template <typename N, typename E> void Graph<N,E>::Node::mergeOut(const N& oldData, const N& newData) const{

}

template <typename N, typename E> void Graph<N,E>::Node::mergeIn(const N& oldData, const Node& newData, std::shared_ptr<N> sp) {
	// for (Edge e: edges) {
	for (int i =0; i < edges.size(); ++i) {	
		if (edges[i].getDest() == oldData) {
			if (!isExisted(newData, edges[i].getWeight())) {
				// e.printEdge();
				edges[i].changeDest(sp);
				edges[i].printEdge();
				edges[0].printEdge();
			}
		}
	}
	// printEdges();
}



template <typename N, typename E> void Graph<N,E>::Node::Edge::changeDest(std::shared_ptr<N> sp) {
	destNode = sp;
	std::cout << "change to " << getDest() << std::endl;

}


// check whether there's a edge from src to dst
template <typename N, typename E> bool Graph<N,E>::isConnected(const N& src, const N& dst) const {
	if (!isNode(src)) {
		throw std::runtime_error("Can't find source node");
	}
	if (!isNode(dst)) {
		throw std::runtime_error("Can't find destination node");
	}
	auto from = findNode(src);

	if ((*from)->isConnected(dst)) return true;
	return false;
}


// check whether a edge with weight and destination already connected to a node
template <typename N, typename E> bool Graph<N,E>::Node::isExisted(const Node& dst, const E& w) const {
	auto checkedW = std::find_if(edges.begin(), edges.end(), [&dst, &w] (const std::shared_ptr<Edge>& e) {
		return w == e->getWeight() && dst.getNode() == e->getDest();
	});
	if (checkedW == edges.end()) return false;
	return true;
}

// check whether a edge with destination already connected to a node
template <typename N, typename E> bool Graph<N,E>::Node::isConnected(const Node& dst) const {
	auto checkedW = std::find_if(edges.begin(), edges.end(), [&dst] (const std::shared_ptr<Edge>& e) {
		return dst.getNode() == e->getDest();
	});
	if (checkedW == edges.end()) return false;
	return true;
}


template <typename N, typename E> bool Graph<N,E>::isNode(const N& val) const {
	auto res = findNode(val);
	if (res == nodes.end() ) return false;
	return true;
}

// method to print all nodes
template <typename N, typename E> void Graph<N,E>::printNodes() const {
	for (auto n: nodes) {
		n->printNode();
	}
}

// print all edges of a node
template <typename N, typename E> void Graph<N,E>::printEdges(const N& val) const {
	if (!isNode(val)) {
		throw std::runtime_error("Can't find the node");
	}
	std::cout << "Edges attached to Node " << val << "\n";
	auto node = findNode(val);
	(*node)->printEdges();
}

// print all edges of this node
template <typename N, typename E> void Graph<N,E>::Node::printEdges() const {
	if (edges.size() == 0) {
		std::cout << "(null)" << std::endl;
	} else {
		for (auto e: edges) {
			e->printEdge();
		}
	}
}

// method to print a node
template <typename N, typename E> void Graph<N,E>::Node::printNode() const {
	std::cout << *(nodePtr) << std::endl;
}


// method to print a edge
template <typename N, typename E> void Graph<N,E>::Node::Edge::printEdge() const {
	std::cout << getDest() << " " << getWeight() << std::endl;
}

// get pointer of a node
template <typename N, typename E> std::shared_ptr<N> Graph<N,E>::Node::getPtr() const {
	return nodePtr;	
}

// get destination of edge
template <typename N, typename E> N& Graph<N,E>::Node::Edge::getDest() const {
	auto dest = destNode.lock();
	return *dest;
}

// get pointer of destination in a edge 
template <typename N, typename E> std::shared_ptr<N> Graph<N,E>::Node::Edge::getDestPtr() const {
	auto dest = destNode.lock();
	return dest;
}